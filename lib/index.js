// Generated by CoffeeScript 1.12.4
var interpolateTransform, interpolateTransforms, interpolateValue, parseDeclValue, parseTransform, parseTransforms, parseValue, postcss, postcss_bounce, springEq, transformToString, transformsToString, valueToString;

postcss = require('postcss');

springEq = function(t, p) {
  if (p == null) {
    p = 0.5;
  }
  return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
};

valueToString = function(arg) {
  var type, value, value_string;
  type = arg.type, value = arg.value;
  value_string = value.toFixed(2);
  if (type === 'px') {
    value_string += 'px';
  } else if (type === 'pct') {
    value_string += '%';
  }
  return value_string;
};

transformToString = function(arg) {
  var type, values;
  type = arg.type, values = arg.values;
  return type + '(' + values.map(valueToString).join(', ') + ')';
};

transformsToString = function(transforms) {
  return transforms.map(function(arg) {
    var type, values;
    type = arg.type, values = arg.values;
    return type + '(' + values.map(valueToString).join(', ') + ')';
  }).join(' ');
};

interpolateValue = function(start_value, end_value, position) {
  var interpolated_value;
  interpolated_value = (end_value.value - start_value.value) * position + start_value.value;
  return {
    type: start_value.type,
    value: interpolated_value
  };
};

interpolateTransform = function(from_transform, to_transform, position) {
  var i, interpolated_transform, ref, results;
  interpolated_transform = {
    type: from_transform.type,
    values: []
  };
  (function() {
    results = [];
    for (var i = 0, ref = from_transform.values.length; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
    return results;
  }).apply(this).map(function(vi) {
    return interpolated_transform.values.push(interpolateValue(from_transform.values[vi], to_transform.values[vi], position));
  });
  return interpolated_transform;
};

interpolateTransforms = function(from_transforms, to_transforms, position) {
  var i, interpolated_transforms, ref, results;
  interpolated_transforms = {
    type: 'transform',
    values: []
  };
  (function() {
    results = [];
    for (var i = 0, ref = from_transforms.values.length; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
    return results;
  }).apply(this).map(function(vi) {
    return interpolated_transforms.values.push(interpolateTransform(from_transforms.values[vi], to_transforms.values[vi], position));
  });
  return interpolated_transforms;
};

parseTransform = function(raw_transform) {
  var inner_transform, type, values;
  type = raw_transform.match(/(\w+)\([^\)]+\)/)[1];
  inner_transform = raw_transform.match(/\w+\(([^\)]+)\)/)[1];
  values = inner_transform.split(',').map(function(s) {
    return s.trim();
  }).map(parseValue);
  return {
    type: type,
    values: values
  };
};

parseTransforms = function(raw_transforms) {
  var ret, transform_matches;
  transform_matches = raw_transforms.match(/\w+\([^\)]+\)/g);
  ret = transform_matches.map(parseTransform);
  return ret;
};

parseValue = function(raw_value) {
  var is_pct, is_px, type, value;
  is_px = raw_value.match(/px$/);
  is_pct = raw_value.match(/%$/);
  if (is_px) {
    type = 'px';
    value = Number(raw_value.replace(/px$/, ''));
  } else if (is_pct) {
    type = 'pct';
    value = Number(raw_value.replace(/%$/, ''));
  } else {
    type = 'number';
    value = Number(raw_value);
  }
  return {
    type: type,
    value: value
  };
};

parseDeclValue = function(decl_value) {
  var ref, type, value, values;
  ref = decl_value.split(':'), type = ref[0], value = ref[1];
  if (type === 'transform') {
    values = parseTransforms(value);
    return {
      type: type,
      values: values
    };
  } else {
    value = parseValue(value);
    return {
      type: type,
      value: value
    };
  }
};

module.exports = postcss_bounce = function(css) {
  var bounces;
  bounces = 0;
  css.walkDecls(function(decl) {
    var at_rule, bounce_from, bounce_to, end_position, i, keyframes_name, n_percents, parsed_from, parsed_to, results, start_position;
    if (decl.prop === 'bounce') {
      keyframes_name = 'bounce' + bounces;
      bounces += 1;
      decl.prop = 'animation';
      decl.value = keyframes_name + ' ' + decl.value + ' forwards';
      bounce_from = null;
      bounce_to = null;
      decl.parent.walkDecls(function(decl) {
        if (decl.prop === 'bounce-from') {
          bounce_from = decl.value;
          decl.remove();
        }
        if (decl.prop === 'bounce-to') {
          bounce_to = decl.value;
          return decl.remove();
        }
      });
      at_rule = postcss.atRule({
        name: 'keyframes',
        params: keyframes_name
      });
      parsed_from = parseDeclValue(bounce_from);
      parsed_to = parseDeclValue(bounce_to);
      end_position = 200;
      start_position = 50;
      n_percents = 5;
      (function() {
        results = [];
        for (var i = 0; 0 <= n_percents ? i <= n_percents : i >= n_percents; 0 <= n_percents ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this).map(function(n) {
        return n * 100 / n_percents;
      }).map(function(percent) {
        var interpolated_decl, interpolated_transforms, interpolated_value, position, position_decl, rule;
        rule = postcss.rule({
          selector: percent + '%'
        });
        position = springEq(percent / 100);
        if (percent === 100) {
          position = 1;
        }
        if (parsed_from.type === 'transform') {
          interpolated_transforms = interpolateTransforms(parsed_from, parsed_to, position);
          interpolated_decl = {
            prop: 'transform',
            value: transformsToString(interpolated_transforms.values)
          };
        } else {
          interpolated_value = interpolateValue(parsed_from.value, parsed_to.value, position);
          interpolated_decl = {
            prop: parsed_from.type,
            value: valueToString(interpolated_value)
          };
        }
        position_decl = postcss.decl(interpolated_decl);
        rule.append(position_decl);
        return at_rule.append(rule);
      });
      return css.prepend(at_rule);
    }
  });
  return css;
};
